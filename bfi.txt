
##########################################
# Start Section
##########################################
GOTO
readloop
##########################################
# Trap Section
##########################################

98: GOTO
trap: 0


##########################################
# Program input section
##########################################
readloop: INPT
inp: 0

copy
endread
trap

COPY
inp
nulltest
decr
nulltest: 0

# ASCII Table
# + 2B
# , 2C
# - 2D
# . 2E
# < 3C
# > 3E
# [ 5B
# ] 5D

###
# Drop Call
###
table_start: table
table: 43 # +  = 1
0  # ,  = 2
0  # -  = 3
0  # .  = 4
13 # <  = 5
1  # >  = 6
28 # [  = 7
1  # ]  = 8

COPY
inp
dropval

COPY
table_start
dropaddr

COPY
afterdrop
dropretaddr

GOTO
DROP
afterdrop: afterdrop

#Copy the value into our instruction list.
COPY
iptr
iptr_indirect
COPY
dropretval
iptr_indirect: 0

###
# end of loop bookkeeping
###
COPY
iptr
eol_incr1

INCR
eol_incr1:0

COPY
eol_incr1
iptr

INCR
instr_count: 0

GOTO
readloop
endread: endread

##########################################
# Interpreter setup
##########################################

COPY
iptr
data_start_address

COPY
data_start_address
dataptr

COPY
instr_start
iptr

#Right now, kill ourselves at endread!
OUTPD
1141411
GOTO
19931

##########################################
# Interpreter section
##########################################

#Iterate over possible instructions

instr:0
interpreterloop: 0

#EOF= 0 (end)
# + = 1 (bf_incr)
# , = 2 (bf_input)
# - = 3 (bf_decr)
# . = 4 (bf_output)
# < = 5 (bf_move_left)
# > = 6 (bf_move_right)
# [ = 7 (bf_loop_left)
# ] = 8 (bf_loop_right)


#set up instruction address
COPY
iptr
iptr_addr
COPY
iptr_addr:0
chkend

COPY
chkend
debug_instr_strt
OUTPD
debug_instr_strt:0

#Check for 0
#(= end of instructions!)
COPY
endinterpret
trap
DECR
chkend: 0

COPY
bf_incr
trap
COPY
chkend
chkincr
DECR
chkincr: 0

COPY 
bf_input
trap
COPY
chkincr
chkinpt
DECR
chkinpt: 0

COPY 
bf_decr
trap
COPY
chkinpt
chkdecr
DECR
chkdecr: 0

COPY 
bf_output
trap
COPY
chkdecr
chkout
DECR
chkout: 0





COPY 
bf_move_left
trap
COPY
chkinpt
chklmove
DECR
chklmove: 0

COPY 
bf_move_right
trap
COPY
chklmove
chkrmove
DECR
chkrmove: 0

COPY 
bf_loop_start
trap
COPY
chkrmove
chklloop
DECR
chklloop: 0

COPY 
bf_loop_end
trap
COPY
chklloop
chkrloop
DECR
chkrloop: 0


post_nonloop_instr: 0
post_loop_instr: 0

COPY
iptr
incrme

INCR
incrme: 0

COPY
incrme
iptr

GOTO
interpreterloop

##########################################
# BrainFuck Subroutines
##########################################

#EOF= 0 (end)
# + = 1 (bf_incr)
# . = 2 (bf_output)
# - = 3 (bf_decr)
# , = 4 (bf_input)
# < = 5 (bf_move_left)
# > = 6 (bf_move_right)
# [ = 7 (bf_loop_start)
# ] = 8 (bf_loop_end)


endinterpret: endinterpret
GOTO
finale

#######
# SETDATA
#######
setdata: COPY
dataptr
dataptr_ptr
COPY
dataptr_ptr : 0
data
data: 0
GOTO
postsetdata: 0


#######
# BF_INCR
#######
bf_incr: bf_incr

COPY
bf_incr_rest
postsetdata
GOTO
setdata
bf_incr_rest:0 

COPY
data
testsign_input
COPY 
pos_path
testsign_pos
COPY 
pos_path
testsign_zero
COPY
neg_path_careful
testsign_neg

GOTO
testsign

pos_path: pos_path

COPY
data
bfincr_1
INCR
bfincr_1: 0
COPY
bfincr_1
bfincr_2
INCR
bfincr_2: 0
COPY
bfincr_2
data

COPY
data
dataptr_ptr

GOTO
post_nonloop_instr

neg_path_careful : neg_path_careful

#Decr once if we're one, twice otherwise
COPY 
after_decrs
trap

COPY
data
bfdecr_1
DECR
bfdecr_1: 0

COPY
bfdecr_1
data
COPY
bfdecr_1
bfdecr_2

DECR
bfdecr_2: 0
COPY
bfdecr_2
data

after_decrs:0
COPY
data
dataptr_ptr

GOTO
post_nonloop_instr

#######
# BF_DECR
#######
bf_decr: bf_decr
COPY
bf_decr_rest
postsetdata
GOTO
setdata
bf_decr_rest:0

COPY
data
testsign_input
COPY 
neg_path_careful
testsign_pos
COPY 
decr_zero
testsign_zero
COPY
pos_path
testsign_neg

GOTO
testsign

decr_zero: decr_zero

COPY
ONE
dataptr_ptr
GOTO
post_nonloop_instr


#######
# bf_move_right
#######
bf_move_right: bf_move_right
COPY
dataptr
dataptr_mr_local1
INCR
dataptr_mr_local1:0

COPY
dataptr_mr_local1
dataptr_mr_local2
INCR
dataptr_mr_local2:0

COPY
dataptr_mr_local2
dataptr
GOTO
post_nonloop_instr


#######
# bf_move_left
#######
bf_move_left: bf_move_left
COPY
dataptr
dataptr_ml_local1
DECR
dataptr_ml_local1:0

COPY
dataptr_ml_local1
dataptr_ml_local2
DECR
dataptr_ml_local2:0

COPY
dataptr_ml_local2
dataptr
GOTO
post_nonloop_instr


#######
# bf_loop_start
#######
bf_loop_start: bf_loop_start
COPY
bf_loopstart_rest
postsetdata
GOTO
setdata
bf_loopstart_rest:0

COPY
jumpfwd
trap

COPY
data
datateststart

DECR
datateststart:0

GOTO
post_nonloop_instr

jumpfwd: jumpfwd

#scan forward in instruction pointer, incrementing for start loop
#and decrementing for end loop. Trap on loopcount < 0
COPY
iptr
reg_a
COPY
jumpfwd_cb1
incr2_end
COPY
jumpfwd_isstart
testctrl_start
COPY
jumpfwd_isend
testctrl_end
COPY
jumpfwd_ignore
testctrl_nonctrl


jumpfwd_ignore: jumpfwd_ignore
jumpfwd_loop: 0
GOTO
incr2
jumpfwd_cb1: jumpfwd_cb1

#Test branch knows to use REGA.
GOTO
testctrl

jumpfwd_isstart: jumpfwd_isstart

COPY
loopcount
jumpfwd_local_incr
INCR
jumpfwd_local_incr:0
COPY
jumpfwd_local_incr
loopcount

GOTO
jumpfwd_loop

jumpfwd_isend: jumpfwd_isend
COPY
loopcount
jumpfwd_local_decr
COPY
jumpfwd_over
trap

DECR
jumpfwd_local_decr: 0

COPY
jumpfwd_local_decr
loopcount

GOTO
jumpfwd_loop

jumpfwd_over:jumpfwd_over
GOTO
post_nonloop_instr

#######
# bf_loop_end
#######
bf_loop_end: bf_loop_end
COPY
bf_loopend_rest
postsetdata
GOTO
setdata
bf_loopend_rest:0

COPY
jumpfwd
trap

COPY
data
datatestend

DECR
datatestend:0

GOTO
post_nonloop_instr

jumpbkwd: jumpbkwd
#Todo

#######
# bf_input
#######
bf_input: bf_input
GOTO
post_nonloop_instr

#######
# bf_output
#######
bf_output: bf_output
GOTO
post_nonloop_instr

##########################################
# testsign subroutine
##########################################
#args
#testsign_neg
#testsign_pos
#testsign_zero
#testsign_input

testsign: 0
COPY 
testsign_zero: 0
trap

DECR
testsign_input: 0

COPY
testsign_input
testsign_local1

testsign_loop: 0

COPY
testsign_neg: 0
trap
DECR
testsign_local1: 0

COPY
testsign_local1
testsign_local2

COPY
testsign_pos: 0
trap
DECR
testsign_local2: 0

COPY
testsign_local2
testsign_local1

GOTO
testsign_loop

##########################################
# DROP subroutine
##########################################
# DROP is a hairy beast.
# Basically, this maps buckets of numbers to
# single numbers.
# dropaddr points to the zeroth bucket,
#	loop:
#		dropval -= dropaddr[i] + 1
#	return i+1
# dropretval is used as the return register.
#
# Note that the logic of loop above implies
# that you want each element of dropaddr
# to be one smaller than the bucket it accepts
#
# given dropaddr = [4,3,3,2]
# 0 - 4 => 1
# 5 - 8 => 2
# 9 - 11 => 3
# 12 - 14 => 4
# 15 and up => Depends what's floating around memory!


#setup
dropaddr:0
DROP:DROP

#args
#dropretaddr: 0 (THE RETURN ADDRESS)
#dropval: 0 (THE INPUT/OUTPUT NUMBER)
#droplen: 0 (THE LENGTH OF THE INPUT TABLE)
#dropaddr: 0 (THE ADDRESS OF THE INPUT TABLE)

COPY
ZERO
dropretval

goto
firstdroploop

droploop:droploop

#increment address
COPY
dropaddr
da_incr
INCR
da_incr: 0
COPY
da_incr
dropaddr

firstdroploop:0
#update result value
INCR
dropretval: 0

#Compute the table element.
#We'll decrement the value this number of times.
COPY
dropaddr
dropaddr_indirect
COPY
dropaddr_indirect:0
drop_table_elem

#output table element for debugging

drop_inner_loop:0

#subtract one from the total value.
#On failure, we're done!
COPY
dropfail
trap
DECR
dropval:0

#subtract one from the loop variable
#On failure, repeat the drop loop!
COPY
droploop
trap
DECR
drop_table_elem:0

GOTO
drop_inner_loop

dropfail: dropfail

GOTO
dropretaddr: 0


##########################################
# "REG_A" subroutines
##########################################

reg_a: 0

########
# INCR2
########
incr2: incr2
COPY
reg_a
i2v1
INCR
i2v1:0
COPY
i2v1
i2v2
INCR
i2v2:0
COPY
i2v2
reg_a
GOTO
incr2_end:0

########
# TESTCTRL
########
testctrl: 0
testctrl_start: 0
testctrl_end: 0
testctrl_nonctrl: 0



finale: finale
##########################################
# Global Data
##########################################


###
# Constants
###
ZERO: 0
ONE: 1
STARTLOOP: 7
ENDLOOP: 8

###
# Global scalars
###
dataptr: 0
iptr: instr_start
loopcount: 0 # natural number
data_start_address: 0

###
# Global vectors
###
# vector format:
# We store 2 different vectors
# Treating 9100 as address 0:
#  addr % 2 == 0 -> nonnegative data address (integer)
#  addr % 2 == 1 -> instructions (ascii code)


9099: 0
instr_start: 0



