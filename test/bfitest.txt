##########################################
# Program input section
##########################################

$ZERO: 0
$ONE: 1
$STARTLOOP: 7
$ENDLOOP: 8

$readloop: INPT
$inp: 0

COPY
$inp
$dbgotp

OUTP
$dbgotp: 0

# ASCII Table
# + 2B
# , 2C
# - 2D
# . 2E
# < 3C
# > 3E
# [ 5B
# ] 5D

###
# Drop Call
###
$TABLE_START: $TABLE
$TABLE: 43 # +  = 1
0  # ,  = 2
0  # -  = 3
0  # .  = 4
13 # <  = 5
1  # >  = 6
28 # [  = 7
1  # ]  = 8
$table_size: 8

COPY
$inp
$dropval

COPY
$table_size
$droplen

COPY
$TABLE_START
$dropaddr

COPY
$afterdrop
$dropretaddr

GOTO
DROP
$afterdrop: $afterdrop

COPY
$dropval
$USERETVAL

OUTP
$USERETVAL: 0

COPY
$USERETVAL
$CURRENT_POS: $INSTR_START

GOTO
25000

##########################################
# DROP subroutine
##########################################
# DROP is a hairy beast.
# Basically, this maps buckets of numbers to
# single numbers.
# dropaddr points to the zeroth bucket,
#	loop:
#		dropval -= dropaddr[i] + 1
#	return i+1
# dropval is reused as the return register.
#
# Note that the logic of loop above implies
# that you want each element of dropaddr
# to be one smaller than the bucket it accepts
#
# given dropaddr = [4,3,3,2]
# 0 - 4 => 1
# 5 - 8 => 2
# 9 - 11 => 3
# 12 - 14 => 4
# 15 and up => Depends what's floating around memory!


#setup
$dropaddr:0
DROP:DROP

#args
#$dropretaddr: 0 (THE RETURN ADDRESS)
#$dropval: 0 (THE INPUT/OUTPUT NUMBER)
#$droplen: 0 (THE LENGTH OF THE INPUT TABLE)
#$dropaddr: 0 (THE ADDRESS OF THE INPUT TABLE)

COPY
$DROPVAL
$DV_VAL

OUTPD
$DV_VAL:0


COPY
$ZERO
$DROPRETVAL

goto
$FIRSTDROPLOOP

$DROPLOOP:$DROPLOOP

#increment address
COPY
$dropaddr
da_incr
INCR
da_incr: 0
COPY
da_incr
$dropaddr

$FIRSTDROPLOOP:0
#update result value
INCR
$dropretval: 0

#Compute the table element.
#We'll decrement the value this number of times.
COPY
$dropaddr
$dropaddr_INDIRECT
COPY
$dropaddr_INDIRECT:0
$DROP_TABLE_ELEM

#output table element for debugging
COPY
$DROP_TABLE_ELEM
$DT_OPT
OUTPD
$DT_OPT:0

$DROP_INNER_LOOP:0

#subtract one from the total value.
#On failure, we're done!
COPY
$dropfail
$TRAP
DECR
$dropval:0

#subtract one from the loop variable
#On failure, repeat the drop loop!
COPY
$DROPLOOP
$TRAP
DECR
$DROP_TABLE_ELEM:0

GOTO
$DROP_INNER_LOOP

$dropfail: $dropfail

COPY
$dropretval
$debug

OUTPD
$debug:0

GOTO
$dropretaddr: 0


3998:GOTO
$trap:0
$INSTR_START:0